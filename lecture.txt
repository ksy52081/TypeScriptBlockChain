#1.5 타입스크립트가 존재하는 이유?
왜 JS 에서 TS로 오는가? 
안정성!
특히 타입 안정성 덕분에 타입스크립트의 장점을 이용할 수 있다.

코드의 버그를 혁신적으로 줄여준다.
자바스크립트는 이해해주려고 한다.
에러를 보여주지 않으려고 노력한다.

예시 
[1,2,3,4] + false
=> '1,2,3,4false'
배열이 문자열이 되어버리고
false라는 boolean도 문자열이 되어버린다!

예시 2

function divide(a,b) {
    return a/b
}

divide(2,3)  
같은 상황일 때 나눗셈을 하기를 기대하고 만든다.

하지만
divide("xxxxx") 와 같이 숫자도 아니고, 인자가 하나밖에 없을 때에도
-> NaN
값을 띄울 뿐 코드 실행 자체를 막아주지 않는다.

예시 3 : 런타임 에러 (콘솔 안에서 발생하는 에러 ~ 유저의 컴퓨터에서 코드가 실행될 때에만 일어나는 에러일 수도 있다)

const nico = {name : "nico"}

nico.hello();
-> Uncauhgt TypeError: nico.hello is not a function

하지만~ 이런 에러는 코드를 실행 하기 전에 최소화 할 수 있는 에러 중 하나이다.
nico 안에 hello 라는 함수가 정의되지 않았음을 누가 봐도 알지만
자바스크립트는 에러날 거라는 걸 몰라서 직접 돌리고 나서야
"아, 잘못되었구나"를 안다는 거다.


#2.0 타입스크립트는 그대로 수행되는 것이 아니라
그 코드를 컴파일 하면 일반적인 js 코드가 된다.
하지만, 타입스크립트 코드에 에러가 있으면 그 코드는 JS로 컴파일 되지 않는다.

무사히 컴파일 됬다는 것은 타입스크립트 코드도 제대로 작성된 것이고
데이터 타입에도 문제가 없었다는 뜻이다.

수강생 노트1)
타입스크립트 코드 테스트
https://www.typescriptlang.org/play

타입스크립트 핸드북
https://typescript-kr.github.io/pages/basic-types.html

타입스크립트란?
1.TypeScript는 JavaScript에 추가적인 구문을 추가하여 editor와의 단단한 통합을 지원합니다. editor에서 초기에 오류를 잡을 수 있습니다.

2. TypeScript 코드는 JavaScript가 실행되는 모든 곳(브라우저, Node.js 또는 Deno 및 앱 등)에서 JavaScript로 변환될 수 있습니다.

3. TypeScript는 JavaScript를 이해하고 타입 추론(type inference)을 사용하여 추가 코드 없이도 훌륭한 도구를 제공합니다.


#2.1 

TypeScript는 두가지를 결합했다.

1. 아니면 그냥 js 처럼 변수만 생성하고 넘어가도 된다. ~ 여기서 좋은 점은 tS가 타입을 추론해준다는 것이다.
2. 데이터와 변수의 타입을 명시적으로 정의할 수 있다.

1) js처럼 변수만 생성해도 찰떡같이 TS가 알아먹는 경우
let a = "hello"
a = "bye"
는 문제 없다. (string -> string 이기 때문에)

but,
a = 1
은 에러가 발생한다. (a는 string이라는 걸 알고 있는 상태에서 string -> integer 이기 때문에)

2) 데이터와 변수의 타입을 명시적으로 정의하는 경우
let b : boolean = "x"
let b : boolean = true
type checker가 b 변수의 값이 정의한 대로 boolean인지 확인해준다.

let c = [1,2,3]
let c : number[] = [1,2,3]
과 같다.
이 숫자 list인 c는
c.push("1")은 작동하지 않고 에러를 출력한다
string을 number의 array에 집어넣으려고 하는 것이기 때문,


#2.2 
optional 타입

const player = {
    name : "SY"
}

타입스크립트가 player 안에 있는 name 은 string이라고 추론함

const player : object = {
    name : "SY"
} 

로 시작할 수 있지만, 이 타입은 쓸모가 없다.
만일 object라고 정의해버리마녀, typescript는 player.name이 존재하는지 모른다.

object 타입에는 name 요소가 없다고 에러가 뜬다.

player 안에 있는 요소들의 타입 정의는 아래처럼 작성해 정의내릴 수 있다.
const player : {
    name : string;
    age : number;
} = {
    name : "SY"
}

이렇게만 작성하면
Property 'age' is missing in type '{ name: string; }' but required in type '{ name: string; age: number; }'.
로 age가 빠진 것에 대해 에러를 출력한다.
하지만 

const player : {
    name : string;
    age? : number;
} = {
    name : "SY"
}
처럼 물음표를 붙이게 되면, 요인이 없더라도 오류를 출력하지 않는다.
사실상 
age? : number 는
age : number or undefined 와 같다. (Optional Parameter)

if(player.age < 10){}
을 하면, age가 undefined 일 수 있다고 에러를 출력한다 그러므로

if(player.age && player.age < 10){}
로 존재 여부와 조건을 같이 붙여줘서 더 안정성 있게 코드를작성한다.



여기서
const playerNico : {
    name : string;
    age? : number;
} = {
    name:"nico"
}

const playerSY : {
    name : string;
    age? : number;
} = {
    name:"SY",
    age:13
}
// 같은 것을 반복하는것은 비효율적이다.

이경우에는 alias 타입을 생성할 수 있다.

type Player ={
    name : string;
    age? : number;
}
//Player는 대문자!

const Nico : Player = {
    name:"nico"
}

const SY : Player = {
    name:"SY",
    age:13
} 

형태로 압축이 가능하다.

const let object list 등 변수에 타입을 할당하는 방법을 배웠다.
그러면 함수는?

function playerMaker(name:string){
    return{
        name:name
    }
}

function playerMaker(name:string) : Player{
    return{
        name:name
    }
}
const nico = playerMaker("nico")
nico.age = 12

화살표 함수로는 어떻게 똑같이 쓸 수 있나?
const playerMaker = (name:string) : Player => ({name})


#2.3

Readonly 타입
tuple : array이지만, 최소한의 길이가 있어야 하고, 특정 위치에 특정 타입이 있어야 한다.

const playerTuple : [string, number, boolean] = ["SY", 12, true]
//최소한 3개 이상의 아이템이 들어가야 하고, 처음 세개의 아이템은 각각 string, number, boolean 타입이어야 한다.

const playerTupleReadOnly : readonly [string, number, boolean] = ["SY", 12, true]

let a : undefined = undefined;
let b : null = null;
let c =[];
//let c : any[] = [];

#2.4 
api 등으로 받을 예정인 데이터의 타입을 모를 경우에는 어떻게 해야 할까? => unknown!

let a : unknown;

=> 어떤 작업을 하려면 이 변수의 타입을 먼저 확인해야 하는 방식으로 보호받게 된다.
 
let a : unknown;
let b = a+1 // err: a is unknown

let a : unknown;
if (typeof a === "number"){
    let b = a+1;
}
if (typeof a ===  "string"){
    let b = a.toUpperCase();
}

======================================
void : 아무것도 return 하지 않는 함수를 대상으로 사용함

function hello() {
    console.log("x");
}
//is same
functon hello() : void {
    console.log("x");
}

const a = hello()
a.toUpperCase //error :Property 'toUpperCase' does not exist on type 'void';
//아무것도 출력하지 않는데 toUpperCase를 쓸 수 있을리가 없음.

=======================================
never : 함수가 절대 return 하지 않을때 발생한다.
함수에서 예외가 발생했을 때

function hello(): never {
    return "x"
} // error : Type 'string' is not assignable to type 'never'.ts(2322)
//에러가 발생한다.


function hello(): never {
    throw new Error("XXX") 
}// 정상작동한다. ~ return 하지 않고 오류를 발생시키는 함수


never는 타입이 두가지일수도 있는 상황에 발생할 수 있다.

예시
function sayHello (name:string|number){
    if( typeof name === "string"){
        name // (parameter) name : string
    } else if (typeof name === "number"){
        name // (parameter) name : number
    } else {
        name // (parameter) name : never 
        //이미 변수 name은 string 이나 number 둘 중에 하나라고 정의내려진 시점에서
        //두가지 경우의 수 모두 체크를 했기 때문에
        //여기에 무얼 쓰던지 그 타입은 never 이다.
        // 이 코드는 절대 실행되지 않아야 한다는 뜻이다.
    }
}

