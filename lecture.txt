#1.5 타입스크립트가 존재하는 이유?
왜 JS 에서 TS로 오는가? 
안정성!
특히 타입 안정성 덕분에 타입스크립트의 장점을 이용할 수 있다.

코드의 버그를 혁신적으로 줄여준다.
자바스크립트는 이해해주려고 한다.
에러를 보여주지 않으려고 노력한다.

예시 
[1,2,3,4] + false
=> '1,2,3,4false'
배열이 문자열이 되어버리고
false라는 boolean도 문자열이 되어버린다!

예시 2

function divide(a,b) {
    return a/b
}

divide(2,3)  
같은 상황일 때 나눗셈을 하기를 기대하고 만든다.

하지만
divide("xxxxx") 와 같이 숫자도 아니고, 인자가 하나밖에 없을 때에도
-> NaN
값을 띄울 뿐 코드 실행 자체를 막아주지 않는다.

예시 3 : 런타임 에러 (콘솔 안에서 발생하는 에러 ~ 유저의 컴퓨터에서 코드가 실행될 때에만 일어나는 에러일 수도 있다)

const nico = {name : "nico"}

nico.hello();
-> Uncauhgt TypeError: nico.hello is not a function

하지만~ 이런 에러는 코드를 실행 하기 전에 최소화 할 수 있는 에러 중 하나이다.
nico 안에 hello 라는 함수가 정의되지 않았음을 누가 봐도 알지만
자바스크립트는 에러날 거라는 걸 몰라서 직접 돌리고 나서야
"아, 잘못되었구나"를 안다는 거다.


#2.0 타입스크립트는 그대로 수행되는 것이 아니라
그 코드를 컴파일 하면 일반적인 js 코드가 된다.
하지만, 타입스크립트 코드에 에러가 있으면 그 코드는 JS로 컴파일 되지 않는다.

무사히 컴파일 됬다는 것은 타입스크립트 코드도 제대로 작성된 것이고
데이터 타입에도 문제가 없었다는 뜻이다.

수강생 노트1)
타입스크립트 코드 테스트
https://www.typescriptlang.org/play

타입스크립트 핸드북
https://typescript-kr.github.io/pages/basic-types.html

타입스크립트란?
1.TypeScript는 JavaScript에 추가적인 구문을 추가하여 editor와의 단단한 통합을 지원합니다. editor에서 초기에 오류를 잡을 수 있습니다.

2. TypeScript 코드는 JavaScript가 실행되는 모든 곳(브라우저, Node.js 또는 Deno 및 앱 등)에서 JavaScript로 변환될 수 있습니다.

3. TypeScript는 JavaScript를 이해하고 타입 추론(type inference)을 사용하여 추가 코드 없이도 훌륭한 도구를 제공합니다.


#2.1 

TypeScript는 두가지를 결합했다.

1. 아니면 그냥 js 처럼 변수만 생성하고 넘어가도 된다. ~ 여기서 좋은 점은 tS가 타입을 추론해준다는 것이다.
2. 데이터와 변수의 타입을 명시적으로 정의할 수 있다.

1) js처럼 변수만 생성해도 찰떡같이 TS가 알아먹는 경우
let a = "hello"
a = "bye"
는 문제 없다. (string -> string 이기 때문에)

but,
a = 1
은 에러가 발생한다. (a는 string이라는 걸 알고 있는 상태에서 string -> integer 이기 때문에)

2) 데이터와 변수의 타입을 명시적으로 정의하는 경우
let b : boolean = "x"
let b : boolean = true
type checker가 b 변수의 값이 정의한 대로 boolean인지 확인해준다.

let c = [1,2,3]
let c : number[] = [1,2,3]
과 같다.
이 숫자 list인 c는
c.push("1")은 작동하지 않고 에러를 출력한다
string을 number의 array에 집어넣으려고 하는 것이기 때문,


#2.2 
optional 타입

const player = {
    name : "SY"
}

타입스크립트가 player 안에 있는 name 은 string이라고 추론함

const player : object = {
    name : "SY"
} 

로 시작할 수 있지만, 이 타입은 쓸모가 없다.
만일 object라고 정의해버리마녀, typescript는 player.name이 존재하는지 모른다.

object 타입에는 name 요소가 없다고 에러가 뜬다.

player 안에 있는 요소들의 타입 정의는 아래처럼 작성해 정의내릴 수 있다.
const player : {
    name : string;
    age : number;
} = {
    name : "SY"
}

이렇게만 작성하면
Property 'age' is missing in type '{ name: string; }' but required in type '{ name: string; age: number; }'.
로 age가 빠진 것에 대해 에러를 출력한다.
하지만 

const player : {
    name : string;
    age? : number;
} = {
    name : "SY"
}
처럼 물음표를 붙이게 되면, 요인이 없더라도 오류를 출력하지 않는다.
사실상 
age? : number 는
age : number or undefined 와 같다. (Optional Parameter)

if(player.age < 10){}
을 하면, age가 undefined 일 수 있다고 에러를 출력한다 그러므로

if(player.age && player.age < 10){}
로 존재 여부와 조건을 같이 붙여줘서 더 안정성 있게 코드를작성한다.



여기서
const playerNico : {
    name : string;
    age? : number;
} = {
    name:"nico"
}

const playerSY : {
    name : string;
    age? : number;
} = {
    name:"SY",
    age:13
}
// 같은 것을 반복하는것은 비효율적이다.

이경우에는 alias 타입을 생성할 수 있다.

type Player ={
    name : string;
    age? : number;
}
//Player는 대문자!

const Nico : Player = {
    name:"nico"
}

const SY : Player = {
    name:"SY",
    age:13
} 

형태로 압축이 가능하다.

const let object list 등 변수에 타입을 할당하는 방법을 배웠다.
그러면 함수는?

function playerMaker(name:string){
    return{
        name:name
    }
}

function playerMaker(name:string) : Player{
    return{
        name:name
    }
}
const nico = playerMaker("nico")
nico.age = 12

화살표 함수로는 어떻게 똑같이 쓸 수 있나?
const playerMaker = (name:string) : Player => ({name})


#2.3

Readonly 타입
tuple : array이지만, 최소한의 길이가 있어야 하고, 특정 위치에 특정 타입이 있어야 한다.

const playerTuple : [string, number, boolean] = ["SY", 12, true]
//최소한 3개 이상의 아이템이 들어가야 하고, 처음 세개의 아이템은 각각 string, number, boolean 타입이어야 한다.

const playerTupleReadOnly : readonly [string, number, boolean] = ["SY", 12, true]

let a : undefined = undefined;
let b : null = null;
let c =[];
//let c : any[] = [];

#2.4 
api 등으로 받을 예정인 데이터의 타입을 모를 경우에는 어떻게 해야 할까? => unknown!

let a : unknown;

=> 어떤 작업을 하려면 이 변수의 타입을 먼저 확인해야 하는 방식으로 보호받게 된다.
 
let a : unknown;
let b = a+1 // err: a is unknown

let a : unknown;
if (typeof a === "number"){
    let b = a+1;
}
if (typeof a ===  "string"){
    let b = a.toUpperCase();
}

======================================
void : 아무것도 return 하지 않는 함수를 대상으로 사용함

function hello() {
    console.log("x");
}
//is same
functon hello() : void {
    console.log("x");
}

const a = hello()
a.toUpperCase //error :Property 'toUpperCase' does not exist on type 'void';
//아무것도 출력하지 않는데 toUpperCase를 쓸 수 있을리가 없음.

=======================================
never : 함수가 절대 return 하지 않을때 발생한다.
함수에서 예외가 발생했을 때

function hello(): never {
    return "x"
} // error : Type 'string' is not assignable to type 'never'.ts(2322)
//에러가 발생한다.


function hello(): never {
    throw new Error("XXX") 
}// 정상작동한다. ~ return 하지 않고 오류를 발생시키는 함수


never는 타입이 두가지일수도 있는 상황에 발생할 수 있다.

예시
function sayHello (name:string|number){
    if( typeof name === "string"){
        name // (parameter) name : string
    } else if (typeof name === "number"){
        name // (parameter) name : number
    } else {
        name // (parameter) name : never 
        //이미 변수 name은 string 이나 number 둘 중에 하나라고 정의내려진 시점에서
        //두가지 경우의 수 모두 체크를 했기 때문에
        //여기에 무얼 쓰던지 그 타입은 never 이다.
        // 이 코드는 절대 실행되지 않아야 한다는 뜻이다.
    }
}

#3.0
배울 개념
call signiture
polymorphism
overloading
generics

call signiture : 함수에 입력한 인자의 type과 return하는 값의 type을 보여주는 명세
const add = (a:number, b:number): number => a+b;
// 함수 위에 마우스를 올렸을 때, const add = (a:number, b:number) => number 라고 보여준다.

우리는 우리만의 call signiture 를 선언하고 싶다.

type AddType = (a:number, b:number) => number;
const add : AddType = (a,b) => a+b;
// 이렇게 하면 이미 각 인자의 타입을 정의했으므로 굳이 add 함수를 정의할 때 인자마다 반복적으로 타입을 명시해 줄 필요가 없어지낟.
// 핵심은 함수의 값 정의와 함수의 데이터의 타입 정의를 나누어서 관리할 수 있다는 강점에 있다.

#3.1 overloading
대부분의 상황에서 다른 사람들이 만든 외부 라이브러리를 사용하는 경우가 대부분인데,
이런 패키지나 라이브러리는 오버로딩이 심하다.

오버로딩이란 무엇인가?

type AddType = (a:number, b:number) => number;
// is same
type AddType = {
    (a:number, b:number) : number
}
왜 굳이 {}로 포장하나?
많은 경우 서로 다른 여러개의 call signiture 를 가질 수 있기 때문이다.

type AddType = {
    (a:number, b:number) : number
    (a:number, b:string) : number
}

const add : AddType = (a,b) => {
    if (typeof b === "string"){
        return a
    }
    return a+b //string 이 아닐 때에는 a+b를 출력
}

============================

실제 예시 Next.js (React의 다른 모듈)
Router.push("/home")
Router.push({
    path : "/home",
    state : 1
})

//이렇게 같은 함수에도 불구하고 string 으로 입력하거나 object로 입력할 수 있다. 양 쪽 다 문제 없이 가동한다.

type Config = {
    path : string,
    state: object,

}

type Push = {
    (path:string):void
    (config : Config):void
}

const push:Push (config)=> {
    if (typeof config === "string"){
        console.log(config)
    }else{
        console.log(config.path)
    }
}

=========================================

하나의 argmuent 가 아니라, 여러개의 argmuent로 이루어졌을 때에는 어떨까?
argment의 갯수가 다를때에는?

type AddType2  = {
    (a:number, b:number) : number
    (a:number, b:number, c:number) : number
}

const add : AddType2 = (a,b,c) =>{
    if(c) return a+b+c
    return a+b
} //Error ~ Type '(a: number, b: number, c: number) => number' is not assignable to type 'AddType2'
// call signiture 를 해석하자면 c는 optional 한거다. 즉 있을 수도 있고 없을 수도 있다.
// 아래처럼 변경시키면 해결된다.

const add : AddType2 = (a,b,c?:number) =>{
    if(c) return a+b+c
    return a+b
}// ?를 언급함으로써 c가 명확하게 optional 한 변수임을 정의한다.

수강생 노트 1)
Function(=Method) Overloading은 직접 작성하기보다 외부 라이브러리에 자주 보이는 형태로, 하나의 함수가 복수의 Call Signature를 가질 때 발생한다

type Add = {
(a: number, b: number): number,
(a: number, b: string): number
}

const add: Add = (a, b) => {
if (typeof b === "string") return a;
return a + b;
}

매개변수의 데이터 타입이 다른 경우 예외 처리

type Add2 = {
(a: number, b: number): number,
(a: number, b: number, c: number): number
}

const add2: Add2 = (a, b, c?: number) => {
if (c) return a + b + c;
return a + b;
}

매개변수의 수가 다른 경우 예외 처리

위와 같은 함수는 거의 없지만 외부 라이브러리에서 활용될 수 있다

router.push("/home");

router.push({
path: "/home",
state: 1
});

예를 들어, Next.js의 라우터 push가 대충 두 가지 방법으로 페이지를 이동한다고 할 때,

type Config = {
path: string,
state: number
}

type Push = {
(config: Config): void,
(config: string): void
}

const push: Push = (config) => {
if (typeof config === "string") console.log(config);
else console.log(config.path);
}

패키지나 라이브러리는 위와 같이 두 가지 경우의 Overloading으로 디자인되어 있을 것이다


#3.2 다형성 polymorphism

poly + morphic = multi + structure/form
여러형태, 여러구조, 여러모형

generic이 어떻게 polymorphism에 영향을 주는가?

예시를 만들어보자

1. call signiture를 만들자

type Superprint{
    (arr: number[]) : void
    (arr: boolean[]) : void
    (arr: (number|boolean)[]) : void
}

const superPrint : Superprint = (arr) => {
    arr.forEach(i => console.log(i))
}

SuperPrint([1,2,3,4])
SuperPrint([true,true,false,false])
SuperPrint(["a","b","c","d"]) // 에러 발생!
SuperPrint([1,2,true,"a"]) //에러 발생

// 문제는, number 배열을 받을 수도 있고,boolean , object 등등 뭐든 배열로 받을 수 있다.

엄청나게 다양한 유형의 타입들이 있는데, 그걸 일일이 다 추가해야 할까?

concrete type : number, boolean, string, void, null, 등등

generic type : placeholder같은 것이다. typescript는 그게 무엇인지 추론해서 함수를 사용할 것이다.

call signiture를 작성할 때, 여기 들어올 확실한 고정되어있는 타입을 모를 때 generic을 사용한다.
분명히 concrete type들의 조합임은 분명하나, 그 type이 무엇인지 특정하지 못한다.

어떻게 사용하나?

type Superprint{
    <T>(arr: T[]) : void
}
// 굳이 T, V가 아니어도 된다,
type Superprint{
    <V>(arr: V[]) : void
    <Generic>(arr: Generic[]) : void
    <Potato>(arr: Potato[]) : void
    <GenericType>(arr: GenericType[]) : void
    <Placeholder>(arr: Placeholder[]) : void
    <TypePlaceholder>(arr: TypePlaceholder[]) : void
    :
    :
    :
}
어느것이든 상관 없다.
그때 그때 상황에 맞게 call signiture를 작성해준다.




type Superprint{
    <TypePlaceholder>(arr: TypePlaceholder[]) : TypePlaceholder
}
const superPrint : Superprint = (arr) => arr[0]